<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NYC Subway Accessibility, Convenience, and Redundancy by Neighborhood</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
        }

        #vis {
            width: 100%;
            height: 80vh;
        }

        #container {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        .tooltip {
            position: absolute;
            padding: 5px;
            border: 1px solid black;
            background: white;
        }
    </style>
</head>

<body>
    <div id="container">
        <svg id="vis"></svg>
    </div>
    <script>
        const container = d3.select("#container");
        const bbox = container.node().getBoundingClientRect();
        const width = bbox.width;
        const height = bbox.height;
        const svg = d3.select("#vis");
        svg.attr("width", width).attr("height", height);

        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
        const CATEGORIES = {
            NUMBER_OF_STATIONS: "NUMBER_OF_STATIONS",
            NUMBER_OF_SERVICES: "NUMBER_OF_SERVICES",
            REACHABLE_NEIGHBORHOODS_SINGLE_SEAT: "REACHABLE_NEIGHBORHOODS_SINGLE_SEAT",
            REACHABLE_NEIGHBORHOODS_ONE_TRANSFER: "REACHABLE_NEIGHBORHOODS_ONE_TRANSFER",
        };
        const LABELS = {
            NUMBER_OF_STATIONS: "Number of Stations",
            NUMBER_OF_SERVICES: "Number of Services",
            REACHABLE_NEIGHBORHOODS_SINGLE_SEAT: "Number of Neighborhoods Reachable on Single-seat Ride",
            REACHABLE_NEIGHBORHOODS_ONE_TRANSFER: "Number of Neighborhoods Reachable with One Transfer",
        };
        const KEYS = {
            NUMBER_OF_STATIONS: "stations",
            NUMBER_OF_SERVICES: "services",
            REACHABLE_NEIGHBORHOODS_SINGLE_SEAT: "single_seat",
            REACHABLE_NEIGHBORHOODS_ONE_TRANSFER: "one_transfer",
        };
        var category = CATEGORIES.REACHABLE_NEIGHBORHOODS_ONE_TRANSFER;
        var selected = null;
        function draw(lines, stations, neighborhoods, data, mapping) {
            const projection = d3.geoMercator();
            const path = d3.geoPath().projection(projection);
            const padding = 20;
            projection.fitExtent([[padding, padding], [width - padding, height - padding]], neighborhoods);

            const station_scale = d3.scaleLinear().domain(d3.extent(data, d => d.stations.length));
            const service_scale = d3.scaleLinear().domain(d3.extent(data, d => d.services.length));
            const single_seat_scale = d3.scaleLinear().domain(d3.extent(data, d => d.single_seat.length));
            const one_transfer_scale = d3.scaleLinear().domain(d3.extent(data, d => d.one_transfer.length));

            const layer1 = svg.append("g");
            const layer2 = svg.append("g");
            const layer3 = svg.append("g");
            const layer4 = svg.append("g");

            function highlightNeighborhood(d) {
                if (selected == null || mapping[selected] == null || mapping[d.properties.ntaname] == null) {
                    return false;
                }
                if (d.properties.ntaname === selected) {
                    return true;
                }
                if (category === CATEGORIES.REACHABLE_NEIGHBORHOODS_ONE_TRANSFER) {
                    return mapping[d.properties.ntaname].one_transfer.has(selected);
                }
                if (category === CATEGORIES.REACHABLE_NEIGHBORHOODS_SINGLE_SEAT) {
                    return mapping[d.properties.ntaname].single_seat.has(selected);
                }
                return false;
            }

            function highlightLine(d) {
                if (selected == null || mapping[selected] == null) {
                    return false;
                }
                if (d.properties.name == "S") {
                    return false;
                }
                if (mapping[selected].services.has(d.properties.rt_symbol)) {
                    return true;
                }
                return d.properties.name.split("-").filter(n => mapping[selected].services.has(n)).length > 0;
            }

            function highlightStation(d) {
                if (selected == null || mapping[selected] == null) {
                    return false;
                }
                return mapping[selected].stations.has(d.id);
            }

            function update() {
                // neighborhoods

                layer1.selectAll("path")
                    .data(neighborhoods.features, d => d.properties.ntaname)
                    .join(enter => enter.append("path")
                        .attr("d", path)
                        .attr("fill", "silver")
                        .attr("stroke", "black")
                        .attr("stroke-width", d => highlightNeighborhood(d) ? 1 : 0.5),
                        update => update.attr("fill", "silver"));

                // draw subway lines
                layer2.selectAll("path")
                    .data(lines.features, d => d.name)
                    .join(enter => enter.append("path")
                        .attr("d", path)
                        .attr("fill", "none")
                        .attr("stroke", d => highlightLine(d) ? "black" : "gray")
                        .attr("stroke-width", d => highlightLine(d) ? 1 : 0.5),
                        update => update.attr("stroke", d => highlightLine(d) ? "black" : "gray"));

                // draw subway stations
                layer3.selectAll("circle")
                    .data(stations, d => d.id)
                    .join(enter => enter.append("circle")
                        .attr("cx", d => projection(d.coord)[0])
                        .attr("cy", d => projection(d.coord)[1])
                        .attr("fill", d => highlightStation(d) ? "white" : "none")
                        .attr("stroke", d => highlightStation(d) ? "black" : "none")
                        .attr("stroke-width", 0.5)
                        .attr("r", 2),
                        update => update.attr("fill", d => highlightStation(d) ? "white" : "none")
                            .attr("stroke", d => highlightStation(d) ? "black" : "none")

                    );

                // draw invisible map for hover
                layer4.selectAll("path")
                    .data(neighborhoods.features, d => d.properties.ntaname)
                    .join(enter => enter.append("path")
                        .attr("d", path)
                        .attr("fill", "white")
                        .attr("stroke", "none")
                        .attr("stroke-width", 0)
                        .style("opacity", 0)
                        .on("mouseover", (_, d) => {
                            selected = d.properties.ntaname;
                            tooltip.html("Test")
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px")
                                .style("opacity", 1);
                            update();
                        })
                        .on("mouseout", (_, d) => {
                            selected = null;
                            tooltip.html("")
                                .style("left", "0px")
                                .style("top", "0px")
                                .style("opacity", 0);
                            update();
                        })

                    );
            }
            update();
        }

        async function onload() {
            const lines = await d3.json("./subway_lines.geojson");

            var stations = await d3.csv("./subway_stations.csv");
            stations.forEach(s => {
                s.coord = [parseFloat(s["GTFS Longitude"]), parseFloat(s["GTFS Latitude"])];
                s.id = parseInt(s["Station ID"]);
            });
            stations = stations.filter(s => s.Borough != "SI");

            var data = await d3.json("./processed_data.json");
            data = data.filter(d => d.stations.length > 0);
            const mapping = {};
            data.forEach(d => {
                Object.values(KEYS).forEach(k => {
                    d[k] = new Set(d[k]);
                })
                d.services.delete("S");
                mapping[d.name] = d;
            });

            const neighborhoods = await d3.json("./2020_NTA.geojson");
            neighborhoods.features = neighborhoods.features.filter(f => f.properties.boroname != "Staten Island");
            draw(lines, stations, neighborhoods, data, mapping);
        }

        onload();
    </script>
</body>

</html>